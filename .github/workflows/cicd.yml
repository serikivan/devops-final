name: CI/CD Pipeline

on:
  push:
    branches: [ "main", "master" ]
  pull_request:
    branches: [ "main", "master" ]
  workflow_dispatch:

env:
  IMAGE_NAME: channel-service

jobs:
  build:
    name: Build Docker Image
    runs-on: [self-hosted, linux, x64]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get short commit SHA
        id: sha
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "SHORT_SHA=${SHORT_SHA}" >> $GITHUB_ENV

      - name: Build Docker image
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          docker build -t ${IMAGE_NAME}:${SHORT_SHA} .
          docker build -t ${IMAGE_NAME}:latest .
          echo "Built image: ${IMAGE_NAME}:${SHORT_SHA}"
          echo "Built image: ${IMAGE_NAME}:latest"

  upload:
    name: Upload to Kind
    runs-on: [self-hosted, linux, x64]
    needs: build
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install kind
        run: |
          if ! command -v kind &> /dev/null; then
            echo "Installing kind..."
            KIND_VERSION="v0.20.0"
            curl -Lo ./kind https://kind.sigs.k8s.io/dl/${KIND_VERSION}/kind-linux-amd64
            chmod +x ./kind
            # Пробуем установить в /usr/local/bin (требует sudo)
            if sudo mv ./kind /usr/local/bin/kind 2>/dev/null; then
              echo "kind installed to /usr/local/bin/kind"
            else
              # Если sudo не работает, устанавливаем в ~/.local/bin
              mkdir -p ~/.local/bin
              mv ./kind ~/.local/bin/kind
              echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
              export PATH="$HOME/.local/bin:$PATH"
              echo "kind installed to ~/.local/bin/kind"
            fi
            # Проверяем, что kind доступен
            which kind || (export PATH="$HOME/.local/bin:$PATH" && which kind)
            kind version
          else
            echo "kind already installed:"
            kind version
          fi
          # Убеждаемся, что kind в PATH для следующих шагов
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Get short SHA
        id: sha
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "SHORT_SHA=${SHORT_SHA}" >> $GITHUB_ENV

      - name: Check if kind cluster exists
        id: kind-check
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          if kind get clusters 2>/dev/null | grep -q "^kind$"; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create kind cluster (if not exists)
        if: steps.kind-check.outputs.exists == 'false'
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          kind create cluster --name kind || true

      - name: Load Docker image into kind
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          kind load docker-image ${IMAGE_NAME}:${SHORT_SHA} --name kind
          kind load docker-image ${IMAGE_NAME}:latest --name kind
          echo "Loaded image ${IMAGE_NAME}:${SHORT_SHA} into kind cluster"

      - name: Verify image in kind
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          docker exec kind-control-plane crictl images | grep ${IMAGE_NAME} || echo "Image verification (may need crictl)"

  deploy:
    name: Deploy to Kubernetes
    runs-on: [self-hosted, linux, x64]
    needs: [build, upload]
    environment:
      name: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install kubectl
        run: |
          if ! command -v kubectl &> /dev/null; then
            echo "Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            if sudo mv kubectl /usr/local/bin/kubectl 2>/dev/null; then
              echo "kubectl installed to /usr/local/bin"
            else
              mkdir -p ~/.local/bin
              mv kubectl ~/.local/bin/kubectl
              echo "$HOME/.local/bin" >> $GITHUB_PATH
              export PATH="$HOME/.local/bin:$PATH"
            fi
            kubectl version --client
          else
            echo "kubectl already installed:"
            kubectl version --client
          fi

      - name: Install kind (if needed for kubeconfig)
        run: |
          if ! command -v kind &> /dev/null; then
            echo "Installing kind for kubeconfig access..."
            KIND_VERSION="v0.20.0"
            curl -Lo ./kind https://kind.sigs.k8s.io/dl/${KIND_VERSION}/kind-linux-amd64
            chmod +x ./kind
            if sudo mv ./kind /usr/local/bin/kind 2>/dev/null; then
              echo "kind installed to /usr/local/bin/kind"
            else
              mkdir -p ~/.local/bin
              mv ./kind ~/.local/bin/kind
              echo "$HOME/.local/bin" >> $GITHUB_PATH
              export PATH="$HOME/.local/bin:$PATH"
            fi
          fi
          export PATH="$HOME/.local/bin:$PATH"
          kind version || echo "kind not available"

      - name: Configure kubectl with KUBECONFIG
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          if [ -z "${{ secrets.KUBECONFIG }}" ]; then
            echo "KUBECONFIG secret is not set. Trying to use kind cluster kubeconfig..."
            # Проверяем, что kind кластер существует и запущен
            if command -v kind &> /dev/null && kind get clusters 2>/dev/null | grep -q "^kind$"; then
              echo "kind cluster found, getting kubeconfig..."
              mkdir -p $HOME/.kube
              
              # Получаем kubeconfig от kind и обновляем его (важно для правильных портов)
              kind get kubeconfig --name kind > $HOME/.kube/config
              chmod 600 $HOME/.kube/config
              
              # Обновляем kubeconfig, чтобы получить актуальные порты
              kind export kubeconfig --name kind || kind get kubeconfig --name kind > $HOME/.kube/config
              
              # Проверяем содержимое kubeconfig
              echo "Kubeconfig server address:"
              kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}' || cat $HOME/.kube/config | grep server
              
              # Убеждаемся, что используется правильный контекст
              kubectl config use-context kind-kind 2>/dev/null || {
                # Пробуем найти правильный контекст
                CONTEXT=$(kubectl config get-contexts -o name | grep kind | head -1)
                if [ -n "$CONTEXT" ]; then
                  kubectl config use-context "$CONTEXT"
                fi
              }
              
              echo "Current context:"
              kubectl config current-context || true
              
              echo "Available contexts:"
              kubectl config get-contexts || true
              
              echo "Using kind cluster kubeconfig"
            else
              echo "KUBECONFIG secret is not set and kind cluster not found."
              echo "Please configure KUBECONFIG in Settings -> Secrets and variables -> Actions -> Environment 'production'"
              echo "Or ensure kind cluster is created in the 'upload' stage"
              exit 1
            fi
          else
            echo "Using KUBECONFIG from secrets"
            mkdir -p $HOME/.kube
            echo "${{ secrets.KUBECONFIG }}" > $HOME/.kube/config
            chmod 600 $HOME/.kube/config
          fi
          echo "Current kubeconfig summary:"
          kubectl config view --minify || true

      - name: Get short SHA
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          echo "SHORT_SHA=${SHORT_SHA}" >> $GITHUB_ENV

      - name: Verify cluster connection
        run: |
          export PATH="$HOME/.local/bin:$PATH"
          export KUBECONFIG=$HOME/.kube/config
          
          echo "Checking cluster connection..."
          echo "KUBECONFIG path: $KUBECONFIG"
          echo "Current context:"
          kubectl config current-context || echo "No current context"
          
          # Ждём немного, чтобы кластер точно был готов
          sleep 5
          
          # Пробуем подключиться с таймаутом
          kubectl cluster-info --request-timeout=30s || {
            echo "Error: Cannot connect to cluster"
            echo "Debugging info:"
            echo "1. Checking kind cluster status:"
            if command -v kind &> /dev/null; then
              kind get clusters
              echo "2. Checking kind containers:"
              docker ps | grep kind || echo "No kind containers running"
              echo "3. Checking kubeconfig server address:"
              kubectl config view --minify | grep server || true
            fi
            # Не падаем с ошибкой, просто выводим предупреждение
            echo "Warning: Cluster connection failed, but continuing..."
          }
          
          # Пробуем получить nodes
          kubectl get nodes --request-timeout=30s || {
            echo "Warning: Cannot get nodes, but continuing with deployment check..."
          }

      - name: Deploy - Get pods
        run: |
          kubectl get pods --all-namespaces

      - name: Deploy - Get services
        run: |
          kubectl get services --all-namespaces

      - name: Deploy - Get deployments
        run: |
          kubectl get deployments --all-namespaces || echo "No deployments found"

